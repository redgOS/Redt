<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Combat: Shades</title>
<script src="https://cdn.tailwindcss.com"></script>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Shojumaru&display=swap');
  body { margin:0; background-color: #1f2937; display:flex; justify-content:center; align-items:center; height:100vh; font-family: 'Inter', sans-serif; }
  #game { 
      background: linear-gradient(to bottom, #87ceeb 70%, #1e3b00 70%, #1e3b00 100%);
      border: 6px solid #111827;
      border-radius: 12px;
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.5), 0 4px 6px -2 rgba(0, 0, 0, 0.2);
  }
  #controlsTab {
    position: absolute; top: 20px; right: 20px; width: 220px;
    background: rgba(17, 24, 40, 0.9); color: white; padding: 12px; cursor: pointer;
    border-radius: 8px; border: 1px solid #374151; z-index: 10; transition: background 0.2s;
  }
  #controlsTab:hover { background: rgba(31, 41, 55, 0.95); }
  #controlsList { display: none; margin-top: 10px; list-style: none; padding: 0; }
  #controlsList li { margin-bottom: 4px; font-size: 0.9rem; color: #d1d5db; }
  .control-title { font-weight: bold; color: #f3f4f6; display: flex; justify-content: space-between; align-items: center; }
</style>
</head>
<body>
<canvas id="game" width="1000" height="600"></canvas>

<div id="controlsTab">
    <div class="control-title">CONTROLS <span id="toggleIcon">▼</span></div>
    <ul id="controlsList">
      <li>W: Jump</li>
      <li>A: Move Back</li>
      <li>D: Move Front</li>
      <li>1: Punch</li>
      <li>2: Uppercut</li>
      <li>3: Hook</li>
      <li>4: Side Kick</li>
      <li>5: Back Kick</li>
    </ul>
</div>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const GRAVITY = 0.8;
const FLOOR_Y = 500;

class Fighter {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.torsoW = 30;
        this.torsoH = 50;
        this.color = color;

        this.vx = 0;
        this.vy = 0;
        this.speed = 6;
        this.onGround = false;
        this.walkCycle = 0;
        this.health = 100;

        this.isAttacking = false;
        this.attackTimer = 0;
        this.attackType = 'punch';
        this.facingRight = true;

        // Cooldowns
        this.lastPunchTime = 0;
        this.lastUppercutTime = 0;
        this.lastHookTime = 0;
        this.lastSideKickTime = 0;
        this.lastBackKickTime = 0;
        this.punchCooldown = 500;
        this.uppercutCooldown = 1000;
        this.hookCooldown = 900;
        this.sideKickCooldown = 800;
        this.backKickCooldown = 1200;

        this.attackDelay = 0;

        // AI
        this.isAI = false;
        this.aiState = 'roam';
        this.stateTimer = 1000;
        this.roamDirection = 1;
        this.circleDirection = 1;
    }

    // Attack functions
    punch() { this._startAttack('punch', this.punchCooldown, 12); }
    uppercut() { this._startAttack('uppercut', this.uppercutCooldown, 12); }
    hook() { this._startAttack('hook', this.hookCooldown, 12); }
    sideKick() { this._startAttack('sideKick', this.sideKickCooldown, 24); }
    backKick() { this._startAttack('backKick', this.backKickCooldown, 24); }

    _startAttack(type, cooldown, duration) {
        const now = Date.now();
        const lastTime = this['last' + type.charAt(0).toUpperCase() + type.slice(1) + 'Time'];
        if (this.onGround && !this.isAttacking && now - lastTime >= cooldown) {
            this.isAttacking = true;
            this.attackTimer = 0;
            this.attackType = type;
            this.vx = 0;
            this.maxAttackTime = duration;
            this['last' + type.charAt(0).toUpperCase() + type.slice(1) + 'Time'] = now;
        }
    }

    update(opponent) {
        this.x += this.vx;
        this.y += this.vy;
        if (opponent) this.facingRight = this.x < opponent.x;

        if (!this.isAttacking && !this.isAI) {
            if (Math.abs(this.vx) > 0.1) this.vx *= 0.85;
            else this.vx = 0;
        }

        if (this.x < 0) this.x = 0;
        if (this.x + this.torsoW > canvas.width) this.x = canvas.width - this.torsoW;

        const charHeight = this.torsoH + 90;
        if (this.y + charHeight < FLOOR_Y) {
            this.vy += GRAVITY;
            this.onGround = false;
        } else {
            this.vy = 0;
            this.y = FLOOR_Y - charHeight;
            this.onGround = true;
        }

        if (this.vx !== 0 && this.onGround && !this.isAttacking) this.walkCycle += 0.2;
        else this.walkCycle = 0;

        if (this.isAttacking) {
            this.attackTimer++;
            if (this.attackTimer >= this.maxAttackTime) {
                this.isAttacking = false;
                this.attackTimer = 0;
            }
        }
    }

    // Hitboxes
    getPunchHitbox() {
        if (!this.isAttacking || this.attackType !== 'punch') return null;
        const punchLength = 60, punchHeight = 10;
        const x = this.facingRight ? this.x + this.torsoW : this.x - punchLength;
        const y = this.y + this.torsoH / 2 - punchHeight / 2;
        return { x, y, w: punchLength, h: punchHeight };
    }

    getUppercutHitbox() {
        if (!this.isAttacking || this.attackType !== 'uppercut') return null;
        const length = 35, height = 30;
        const x = this.facingRight ? this.x + this.torsoW : this.x - length;
        const y = this.y + this.torsoH / 4;
        return { x, y, w: length, h: height };
    }

    getHookHitbox() {
        if (!this.isAttacking || this.attackType !== 'hook') return null;
        const length = 50, height = 15;
        const x = this.facingRight ? this.x + this.torsoW : this.x - length;
        const y = this.y + this.torsoH / 2 - height / 2;
        return { x, y, w: length, h: height };
    }

    getSideKickHitbox() {
        if (!this.isAttacking || this.attackType !== 'sideKick') return null;
        const length = 70, height = 10;
        const x = this.facingRight ? this.x + this.torsoW : this.x - length;
        const y = this.y + this.torsoH / 2 - height / 2;
        return { x, y, w: length, h: height };
    }

    getBackKickHitbox() {
        if (!this.isAttacking || this.attackType !== 'backKick') return null;
        const length = 80, height = 12;
        const x = this.facingRight ? this.x + this.torsoW : this.x - length;
        const y = this.y + this.torsoH / 2 - height / 2;
        return { x, y, w: length, h: height };
    }

draw() {
    const torsoX = this.x, torsoY = this.y, torsoW = this.torsoW, torsoH = this.torsoH;
    ctx.fillStyle = this.color;
    ctx.strokeStyle = this.color;
    ctx.lineWidth = 6;

    // Torso
    ctx.beginPath();
    ctx.moveTo(torsoX + 5, torsoY);
    ctx.lineTo(torsoX + torsoW - 5, torsoY);
    ctx.lineTo(torsoX + torsoW, torsoY + torsoH);
    ctx.lineTo(torsoX, torsoY + torsoH);
    ctx.closePath();
    ctx.fill();

    // Head
    ctx.beginPath();
    ctx.arc(torsoX + torsoW / 2, torsoY - torsoH * 0.25, torsoW / 2, 0, Math.PI * 2);
    ctx.fill();

    // Determine swing for normal walk
    const armSwing = Math.sin(this.walkCycle) * 20;
    const legSwing = Math.sin(this.walkCycle) * 20;

    // Kicks (sideKick & backKick)
    if (this.isAttacking && (this.attackType === 'sideKick' || this.attackType === 'backKick')) {
        let progress = this.attackTimer / this.maxAttackTime;
        if (progress > 1) progress = 1;

        // Kick length
        let kickLength = this.attackType === 'backKick' ? 80 : 70;

        // SideKick plays twice as fast visually
        if (this.attackType === 'sideKick') {
            let fastProgress = progress * 2;
            if (fastProgress > 1) fastProgress = 1;
            kickLength *= fastProgress;
        } else {
            kickLength *= progress;
        }

        const startX = torsoX + (this.facingRight ? torsoW : 0);
        const startY = torsoY + torsoH;
        const endX = this.facingRight ? startX + kickLength : startX - kickLength;
        const endY = startY - 10 * progress;

        // Draw kicking leg
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(endX, endY);
        ctx.stroke();

        // Stationary other leg
        ctx.beginPath();
        ctx.moveTo(torsoX + 5, torsoY + torsoH);
        ctx.lineTo(torsoX - 10, torsoY + torsoH + 80);
        ctx.stroke();
    } else {
        // Normal arms
        ctx.beginPath();
        ctx.moveTo(torsoX + 5, torsoY + 10);
        ctx.lineTo(torsoX - 20, torsoY + 20 + armSwing);
        ctx.lineTo(torsoX - 40, torsoY + 30 + armSwing);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(torsoX + torsoW - 5, torsoY + 10);
        ctx.lineTo(torsoX + torsoW + 20, torsoY + 20 - armSwing);
        ctx.lineTo(torsoX + torsoW + 40, torsoY + 30 - armSwing);
        ctx.stroke();

        // Normal legs
        ctx.beginPath();
        ctx.moveTo(torsoX + 5, torsoY + torsoH);
        ctx.lineTo(torsoX - 10, torsoY + torsoH + 40 + legSwing);
        ctx.lineTo(torsoX - 15, torsoY + torsoH + 80 + legSwing);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(torsoX + torsoW - 5, torsoY + torsoH);
        ctx.lineTo(torsoX + torsoW + 10, torsoY + torsoH + 40 - legSwing);
        ctx.lineTo(torsoX + torsoW + 15, torsoY + torsoH + 80 - legSwing);
        ctx.stroke();
    }

    // Attack hitbox visualization
    if (this.isAttacking) {
        let hb = null;
        if (this.attackType === 'punch') hb = this.getPunchHitbox();
        else if (this.attackType === 'uppercut') hb = this.getUppercutHitbox();
        else if (this.attackType === 'hook') hb = this.getHookHitbox();
        else if (this.attackType === 'sideKick') hb = this.getSideKickHitbox();
        else if (this.attackType === 'backKick') hb = this.getBackKickHitbox();

        if (hb) {
            ctx.fillStyle =
                this.attackType === 'punch' ? 'rgba(255,0,0,0.7)' :
                this.attackType === 'uppercut' ? 'rgba(255,165,0,0.7)' :
                this.attackType === 'hook' ? 'rgba(0,255,255,0.7)' :
                'rgba(0,200,255,0.7)';
            ctx.fillRect(hb.x, hb.y, hb.w, hb.h);
        }
    }
}


// Player & AI
const player=new Fighter(150,FLOOR_Y-150,'black');
const ai=new Fighter(800,FLOOR_Y-150,'black');
ai.health = 300;
ai.isAI = true;

// Controls
const keys={a:false,d:false,w:false,'1':false,'2':false,'3':false,'4':false,'5':false};
window.addEventListener('keydown',e=>{
    if(keys.hasOwnProperty(e.key)) keys[e.key]=true;
});
window.addEventListener('keyup',e=>{
    if(keys.hasOwnProperty(e.key)) keys[e.key]=false;
});

// AI Logic
function updateAI(){
    const now = Date.now();
    const dx = player.x - ai.x;
    const dist = Math.abs(dx);

    ai.stateTimer -= 16;
    if(ai.stateTimer <= 0){
        const r = Math.random();
        if(r < 0.4) ai.aiState = 'approach';
        else if(r < 0.7) ai.aiState = 'roam';
        else ai.aiState = 'circle';
        ai.stateTimer = 1500 + Math.random()*2000;

        if(ai.aiState==='roam') ai.roamDirection = Math.random()<0.5?-1:1;
        if(ai.aiState==='circle') ai.circleDirection = Math.random()<0.5?-1:1;
    }

    if(dist < 140 && Math.random() < 0.39) ai.vx = dx>0?-ai.speed*1.5:ai.speed*1.5;

    if(dist < 60) ai.vx = dx>0?-ai.speed:ai.speed;
    else if(ai.aiState==='approach') ai.vx = dx>0?ai.speed:-ai.speed;
    else if(ai.aiState==='roam'){ ai.vx = ai.roamDirection*ai.speed; if(Math.random()<0.01) ai.roamDirection*=-1; }
    else if(ai.aiState==='circle'){ ai.vx = ai.circleDirection*ai.speed/2; if(Math.random()<0.01) ai.circleDirection*=-1; }

    if(player.y + player.torsoH < ai.y && ai.onGround && Math.random()<0.05) ai.vy=-12;

    if(dist<=100 && !ai.isAttacking && ai.attackDelay<=0){
        const canAttack = [];
        if(now - ai.lastPunchTime >= ai.punchCooldown) canAttack.push('punch');
        if(now - ai.lastUppercutTime >= ai.uppercutCooldown) canAttack.push('uppercut');
        if(now - ai.lastHookTime >= ai.hookCooldown) canAttack.push('hook');
        if(now - ai.lastSideKickTime >= ai.sideKickCooldown) canAttack.push('sideKick');
        if(now - ai.lastBackKickTime >= ai.backKickCooldown) canAttack.push('backKick');

        if(canAttack.length>0){
            const choice = canAttack[Math.floor(Math.random()*canAttack.length)];
            ai[choice]();
        }
        ai.attackDelay = 400 + Math.random()*600;
    } else { ai.attackDelay -=16; if(ai.attackDelay<0) ai.attackDelay=0; }
}

// Controls Tab
const controlsTab=document.getElementById('controlsTab');
const controlsList=document.getElementById('controlsList');
const toggleIcon=document.getElementById('toggleIcon');
controlsTab.addEventListener('click',(e)=>{
    const isVisible=controlsList.style.display==='block';
    controlsList.style.display=isVisible?'none':'block';
    toggleIcon.textContent=isVisible?'▼':'▲';
    e.stopPropagation();
});

// Collision
function checkCollision(attacker,target){
    if(!attacker.isAttacking || attacker.attackTimer!==1) return;

    let box=null;
    if(attacker.attackType==='punch') box=attacker.getPunchHitbox();
    else if(attacker.attackType==='uppercut') box=attacker.getUppercutHitbox();
    else if(attacker.attackType==='hook') box=attacker.getHookHitbox();
    else if(attacker.attackType==='sideKick') box=attacker.getSideKickHitbox();
    else if(attacker.attackType==='backKick') box=attacker.getBackKickHitbox();
    if(!box) return;

    const tX=target.x, tY=target.y, tW=target.torsoW, tH=target.torsoH+90;

    if (box.x < tX + tW && box.x + box.w > tX && box.y < tY + tH && box.y + box.h > tY) {
        let knockback=15, damage=10;
        if(attacker.attackType==='uppercut'){ damage=20; knockback=30; target.vy=-15; }
        else if(attacker.attackType==='hook'){ damage=15; target.vy=-5; }
        else if(attacker.attackType==='sideKick'){ damage=15; knockback=20; target.vy=-5; }
        else if(attacker.attackType==='backKick'){ damage=30; knockback=25; target.vy=-8; }
        else { target.vy=-5; }
        target.health=Math.max(0,target.health-damage);
        target.vx = attacker.facingRight ? knockback : -knockback;
    }
}

// Animate
function animate(){
    requestAnimationFrame(animate);
    ctx.clearRect(0,0,canvas.width,canvas.height);

    ctx.fillStyle='#ffcc00'; ctx.beginPath();
    ctx.arc(50,50,20,0,Math.PI*2); ctx.fill();

    ctx.strokeStyle='#222'; ctx.lineWidth=2;
    ctx.beginPath(); ctx.moveTo(0,FLOOR_Y); ctx.lineTo(canvas.width,FLOOR_Y); ctx.stroke();

    ctx.font='36px Shojumaru'; ctx.textAlign='center'; ctx.lineWidth=4;
    ctx.strokeStyle='#333'; ctx.strokeText('COMBAT: SHADES',canvas.width/2,40);
    ctx.fillStyle='white'; ctx.fillText('COMBAT: SHADES',canvas.width/2,40);

    player.vx=0;
    if(!player.isAttacking){
        if(keys.a) player.vx=-player.speed;
        if(keys.d) player.vx=player.speed;
        if(keys.w && player.onGround) player.vy=-15;
    }
    if(keys['1']) player.punch();
    if(keys['2']) player.uppercut();
    if(keys['3']) player.hook();
    if(keys['4']) player.sideKick();
    if(keys['5']) player.backKick();

    updateAI();
    player.update(ai); ai.update(player);
    checkCollision(player, ai); checkCollision(ai, player);

    player.draw(); ai.draw();

    const barWidth=200, barHeight=20;
    ctx.font='16px sans-serif';
    ctx.fillStyle='white'; ctx.textAlign='left'; ctx.fillText('SHADE',10,20);
    ctx.fillStyle='#4ade80'; ctx.fillRect(10,30,barWidth*(player.health/100),barHeight);
    ctx.strokeStyle='black'; ctx.strokeRect(10,30,barWidth,barHeight);

    ctx.fillStyle='white'; ctx.textAlign='right'; ctx.fillText('FIGHTER',canvas.width-10,20);
    ctx.fillStyle='#4ade80';
    const aiMaxHealth=300;
    ctx.fillRect(canvas.width-10-(barWidth*(ai.health/aiMaxHealth)),30,barWidth*(ai.health/aiMaxHealth),barHeight);
    ctx.strokeStyle='black'; ctx.strokeRect(canvas.width-210,30,barWidth,barHeight);

    if(ai.health<=0){ ctx.font='72px Shojumaru'; ctx.fillStyle='#fef08a'; ctx.textAlign='center'; ctx.fillText('VICTORY!',canvas.width/2,canvas.height/2);}
    if(player.health<=0){ ctx.font='72px Shojumaru'; ctx.fillStyle='#ff0000'; ctx.textAlign='center'; ctx.fillText('DEFEAT!',canvas.width/2,canvas.height/2);}
}

animate();
</script>
</body>
</html>
